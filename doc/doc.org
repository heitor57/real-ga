#+TITLE: Algoritmo genético com representação real
#+SUBTITLE: Algoritmos Bioinspirados
#+AUTHOR: Heitor Lourenço Werneck
#+EMAIL: heitorwerneck@hotmail.com
#+DATE: 
#+LANGUAGE: pt
#+OPTIONS: ^:nil email:nil author:nil toc:nil
#+LATEX_HEADER: \author{Heitor Lourenço Werneck \\github.com/heitor57\\{\href{mailto:heitorwerneck@hotmail.com}{heitorwerneck@hotmail.com}}}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
# mathtools ja inclui amsmath #+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage[binary-units=true]{siunitx}
#+LATEX_HEADER: \usepackage[top=0.5cm,bottom=1.5cm,left=2cm,right=2cm]{geometry}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage[Algoritmo]{algorithm}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{colortbl}
#+LATEX_HEADER: \usepackage{graphicx,wrapfig,lipsum}
#+LATEX_HEADER: \usepackage{pifont}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{rotating}
#+LATEX_HEADER: \usepackage{multirow}
#+LATEX_HEADER: \usepackage{tablefootnote}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage{dblfloatfix}
#+LATEX_HEADER: \usepackage{color, colortbl}
#+LATEX_HEADER: \usepackage{chngcntr}
#+LATEX_HEADER: \usepackage{epstopdf}
#+latex_class_options: [11pt]

#+PROPERTY: header-args :eval no-export
#+BEGIN_EXPORT latex
\usetikzlibrary{arrows, fit, matrix, positioning, shapes, backgrounds,intersections}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{automata, positioning, arrows}
\usetikzlibrary{calc}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\BeforeBeginEnvironment{minted}{\begin{mdframed}[backgroundcolor=bg]}
\AfterEndEnvironment{minted}{\end{mdframed}}
\numberwithin{equation}{section}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}

% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [ellipse, draw, fill=red!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3.5cm,
%    minimum height=2em]


\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% Numbering fix
\counterwithout{equation}{section} % undo numbering system provided by phstyle.cls
%\counterwithin{equation}{chapter}  % implement desired numbering system

#+END_EXPORT


* Introdução
Algoritmos genéticos se referem a uma família de modelos computacionais inspirados na evolução(seleção natural e genética). Esses algoritmos representam a solução problema atráves de estruturas semelhantes a cromossomos e aplicam operadores de recombinação para preservar os dados/informações vitais cite:whitley94_genet_algor_tutor,goldenberg1989genetic. Normalmente um algoritmo genético será baseado em população e usará operadores de seleção e recombinação para buscar uma solução no espaço de busca cite:whitley94_genet_algor_tutor.

Algoritmos genéticos são utilizados em diversos cenários pela natureza generalista de seu modelo, como por exemplo: sistemas de recomendação cite:naruchitparames2011friend,silva2010graph; visão computacional cite:gong2004quadtree; robôs de limpeza cite:yakoubi2016path; recuperação de informação cite:vrajitoru1998crossover e agendamento de voos cite:lee2007multi.

Os algoritmos genéticos também possuem a capacidade de fazer /exploitation/ e /exploration/ que são características de modelos estado da arte em diversas áreas, como por exemplo: /Multi-Armed Bandits/; Nuvem de partículas e outros. Uma característica extremamente importante para diversos cenários.

Esse trabalho consiste na implementação e análise de um algoritmo genético com representação real para solução de um problema de otimização de uma função.

* Problema

O problema é simples e consiste na minimização da função da equação ref:eq:of. 
#+begin_export latex
\begin{equation}
\label{eq:of}
F_o(x) = -20\epsilon^{-0.2}\sqrt{\frac{1}{n}\sum x_i^2} - \epsilon^{\frac{1}{n}\sum cos(2\pi x_i)} + 20 + \epsilon
\end{equation}
#+end_export

É importante notar que como o problema será representado em um sistema computacional como um número real então o espaço de busca terá $2^{\text{bits}}$ possibilidades de solução. Isso mostra que é um problema difícil, pois possui uma complexidade de ordem exponencial no espaço de soluções, por isso é importante usar alguma heurística ou meta-heurística (que no caso é algoritmo genético) para solucionar esse problema caso não tenha solução analítica viável.

* Solução

As estruturas básicas para o algoritmo foram determinadas da seguinte forma: os genes são números reais e não precisam de nenhuma transformação para serem aplicados na equação eqref:eq:of, essa representação é, em comparação com o número de bits utilizado na outra representação do trabalho anterior, muito mais complexa em termos de quantidade de possíveis soluções (espaço de busca bem maior), claro que o espaço de busca poderia ser ainda maior com a representação por bits, porém em termos de eficiência na busca está implementação é mais efetiva. O espaço de busca continua sendo discreto porém bem maior do que com os números de bits utilizados no trabalho anterior. Como a linguagem utilizada foi Python e nessa linguagem o tipo de dado utilizado para representar um gene (o número real) foi o float. O float em Python é majoritariamente mapeado para IEEE-754 “precisão dupla” nas plataformas, inclusive a usada para fazer o experimento.

Para guiar a busca o estado de busca de soluções foi dentro do domínio $max_{value} = -2$ e $min_{value} = 2$ (i.e. $x \in [min_{value},max_{value}]$), isso por que foi analisado que dentro dessa espaço há bons valores para minimização da função e possivelmente a solução ótima do problema.

A estratégia de seleção de pais utilizada foi a roleta, tal que um indivíduo é selecionado a partir de um procedimento que define uma probabilidade de ser escolhido para cada indivíduo com base em seu fitness e após isso um indivíduo é escolhido a partir desse conjunto de probabilidades. Para a atribuição das probabilidades é necessário transformar o fitness, pois como é um problema de minimização então os indíviduos com menores fitness devem ser os indíviduos mais priorizados, para isso cada fitness foi aplicado em $f(x) = 1/(x+\text{Menor float positivo da linguagem})$ após isso o conjunto de probabilidades é construido $\{\frac{f(x)}{\sum_{y\in fitnesses} f(y)}: x \in fitnesses \}$. 

Para a intensificação do espaço de busca foi definido duas estratégias de cruzamento, sendo elas: $BLX\text{-}\alpha$ que sorteia um número aleatório de uma distribuição uniforme dentro de um intervalo que é delimitado a partir dos menores e maiores genes e variados a partir da diferença do produto da diferença dos genes dos pais com \alpha e esse intervalo é limitado pelo intervalo $[min_{value},max_{value}]$, ou seja, os valores não podem passar desses limites e se passam se transformam nos limites passados; $BLX\text{-}\alpha\beta$ que sorteia um número aleatório de uma distribuição uniforme dentro de um intervalo que varia dependendo de qual pai tem o maior gene assim o parâmetro $\beta$ limita o espaço de busca na direção do pior fitness e o $\alpha$ limita o espaço de busca na direção do melhor fitness, normalmente $\alpha>\beta$, e os intervalos também são limitados em $[min_{value},max_{value}]$.

Quando a taxa de cruzamento não é de 100% então indivíduos da população anterior são adicionados aleatoriamente a nova população até o limite de indivíduos.

Para mutação dos indivíduos foi utilizado um parâmetro de taxa de mutação que define a probabilidade de um indivíduo ser mutado. A mutação foi definida como o sorteio de um gene para ter o valor trocado através de outro sorteio de um valor dentro do intervalo $[min_{value},max_{value}]$.

Para garantir uma curva de convergência sem oscilação e constante busca a melhorar os valores o elitismo foi aplicado e definido como a preservação do indivíduo com maior aptidão da população anterior, ele substitui um indivíduo aleatório da nova população. 

Os parâmetros mais relevantes são mostrados na tabela a seguir, através dele o algoritmo genético pode ser ajustado para obter boas soluções, fora as mudanças nos operadores de seleção (i.e., $BLX\text{-}\alpha$ e $BLX\text{-}\alpha\beta$), cruzamento e mutação (aqui, no caso, não foram estudadas outras variações).

#+CAPTION: Parâmetros
| Parâmetro                | Descrição                                                           |
| $min_{value}$            | Limite inferior do espaço de busca                                  |
| $max_{value}$            | Limite superior do espaço de busca                                  |
| #População               | Quantidade de indivíduos                                            |
| #Gerações                | Quantidade de gerações                                              |
| Taxa de cruzamento       | Taxa do número de indivíduos que vão cruzar                         |
| Probabilidade de mutação | Probabilidade da mutação de um indivíduo                            |
| Elitismo                 | Se irá usar a preservação do melhor indivíduo da população anterior |


Uma visão geral de como o algoritmo funciona é dado a seguir:
#+begin_export latex
\begin{algorithm}
  \caption{Algoritmo genético}
  \begin{algorithmic}[1]
  \State Inicia a população com cromossomos aleatórios
  \For{$i=1$ to \#Gerações}
  \State Cruza os indivíduos utilizando a roleta para selecionar os pais e de acordo com a taxa de cruzamento
  \State Completa o número de índivíduos com indivíduos aleatórios da população anterior caso a taxa de cruzamento não seja de 100\%
  \State Faz a mutação dos indivíduos da população atual de acordo com a probabilidade de mutação
  \If{Elitismo}
  \State Seleciona o melhor indivíduo da população anterior e substitui um indíviduo aleatório da geração corrente
  \EndIf
  \EndFor
  \end{algorithmic}
\end{algorithm}
#+end_export


* Resultados

Para a análise de resultados foi utilizado 10 execuções para cada conjunto de parâmetro, devido a natureza probabilística do problema é importante sempre sumarizar os resultados de varias execuções para ter uma ideia do resultado esperado.

** Calibragem de parâmetros

Para começo da análise um experimento fatorial completo será realizado. Os valores para busca estão indicados tabela a seguir com o domínio de busca para cada parâmetro (tabela ref:tbl:hyperparameter).

#+CAPTION: Domínio de busca de cada parâmetro.
#+LABEL: tbl:hyperparameter
|--------------------------+-------------------------------------------------|
| Operador de cruzamento   | {$BLX\text{-}\alpha$, $BLX\text{-}\alpha\beta$} |
| Elitismo                 | {False, True}                                   |
| #Gerações                | {25,50,100}                                     |
| #População               | {25,50,100}                                     |
| Taxa de cruzamento       | {0.6, 0.8, 1.0}                                 |
| Probabilidade de mutação | {0.01, 0.05, 0.1}                               |
|--------------------------+-------------------------------------------------|


A partir da execução o /top/-10 de parâmetros são descritos na tabela a seguir:

|------------+-----------+--------------------+-----------------+------------------------+----------------------------|
| #População | #Gerações | Taxa de cruzamento | Taxa de mutação |            Média $F_o$ | Desvio padrão        $F_o$ |
|------------+-----------+--------------------+-----------------+------------------------+----------------------------|
|        100 |       100 |                0.8 |            0.01 |              3.982e-05 |               2.949474e-05 |
|        100 |       100 |                1.0 |            0.01 |             6.5716e-05 |              9.0926290e-05 |
|        100 |       100 |                0.6 |            0.01 |              0.0001981 |                 0.00019136 |
|         50 |       100 |                0.6 |            0.01 |              0.0002714 |                0.000179354 |
|         50 |       100 |                0.8 |            0.01 |               0.000417 |                0.000392633 |
|        100 |        50 |                0.6 |            0.01 |                0.00049 |                0.000307831 |
|        100 |        50 |                0.8 |            0.01 |              0.0007104 |                0.000726924 |
|         50 |       100 |                1.0 |            0.01 |             0.00125232 |                 0.00116128 |
|         50 |        50 |                0.8 |            0.01 |              0.0013694 |                0.001276186 |
|        100 |       100 |                1.0 |            0.05 |              0.0017521 |                0.002844937 |



É interessante se notar que os três melhores conjunto de parâmetros so se diferenciam pela taxa de cruzamento. E mesmo somente pela taxa de cruzamento é possível observar uma diferença significativa entre o /top/-1 e o /top/-3, assim mostrando a importancia desse parâmetro. É possível ver que as melhores soluções para esse problema não utilizam diversificação de maneira ingenua, sendo mais conservador nas operações de mutação e cruzamento. Também é importante notar que o alto valor de população e gerações é importante para essa configuração mais conservadora pois ele converge para a melhor solução lentamente.

Na figura ref:fig:best_executions há as execuções do algoritmo com o melhor parâmetro, é possível ver que ele chega em um valor baixo rapidamente porém continua convergindo até a solução durante as gerações. Também houve pouca variação nas execuções, como também foi mostrado na tabela, porém no começo poucas execuções demoram a descer para próximo do valor ótimo.

#+begin_export latex
\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.5]{../img/best_executions.eps}
	\label{fig:best_executions}
	\caption{Execuções do melhor parâmetro}
\end{figure}
#+end_export


* Conclusão

Com esse trabalho foi possível fazer a análise detalhada do comportamento de um modelo de algoritmo genético. Atráves de multiplos gráficos os parâmetros do modelo foram análisados. Como o problema a ser tratado é bem simples o algoritmo majoritariamente consegue achar o ponto ótimo do domínio.

bibliography:doc.bib
bibliographystyle:plain
